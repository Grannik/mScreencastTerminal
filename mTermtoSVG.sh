#!/bin/bash
 E='echo -e';    # -e включить поддержку вывода Escape последовательностей
 e='echo -en';   # -n не выводить перевод строки
 c="+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+"
 trap "R;exit" 2 #
    ESC=$( $e "\e")
   TPUT(){ $e "\e[${1};${2}H" ;}
  CLEAR(){ $e "\ec";}
# 25 возможно это
  CIVIS(){ $e "\e[?25l";}
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
MARK(){ $e "\e[1;45m";}
# 0 это цвет списка
 UNMARK(){ $e "\e[0m";}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Эти строки задают цвет фона ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  R(){ CLEAR ;stty sane;CLEAR;};                 # в этом варианте фон прозрачный
 HEAD(){ for (( a=2; a<=28; a++ ))
  do
 TPUT $a 1
        $E "\033[1;35m\xE2\x94\x82                                                                                                                                  \xE2\x94\x82\033[0m";
  done
 TPUT 3 3
        $E "\033[1;36m*** termtosvg ***\033[0m";
 TPUT 4 3
        $E "\033[90mЗапись терминальных сессий как отдельных SVG-анимаций\033[0m";
 TPUT 5 1
        $E "\033[35m+----------------------------------------------------------------------------------------------------------------------------------+\033[0m";
 TPUT 9 1
        $E "\033[35m+ Команды ---------------------------------------------------------------------------------- Commands -----------------------------+\033[0m";
 TPUT 10 3
        $E "\033[90mПо умолчанию termtosvg отображает SVG-анимацию сеанса оболочки.\033[0m";
 TPUT 11 3
        $E "\033[90mЕсли имя выходного файла не указано, будет выбрано случайное имя временного файла сгенерированного автоматически.\033[0m";
 TPUT 15 1
        $E "\033[35m+ Опции ------------------------------------------------------------------------------------ Options ------------------------------+\033[0m";
 TPUT 26 1
        $E "\033[35m+ Up \xE2\x86\x91 \xE2\x86\x93 Down Select Enter --------------------------------------------------------------------------------------------------------+\033[0m";
 MARK;TPUT 1 1
        $E "$c";UNMARK;}
   i=0; CLEAR; CIVIS;NULL=/dev/null
# 32 это расстояние сверху и 48 это расстояние слева
   FOOT(){ MARK;TPUT 29 1
        $E "$c";UNMARK;}
# это управляет кнопками ввер/хвниз
 i=0; CLEAR; CIVIS;NULL=/dev/null
#
 ARROW(){ IFS= read -s -n1 key 2>/dev/null >&2
           if [[ $key = $ESC ]];then
              read -s -n1 key 2>/dev/null >&2;
              if [[ $key = \[ ]]; then
                 read -s -n1 key 2>/dev/null >&2;
                 if [[ $key = A ]]; then echo up;fi
                 if [[ $key = B ]];then echo dn;fi
              fi
           fi
           if [[ "$key" == "$($e \\x0A)" ]];then echo enter;fi;}
  M0(){ TPUT  6 3; $e " Oбзор                                                                                     \033[32mSynopsis                            \033[0m";}
  M1(){ TPUT  7 3; $e " Окружающая среда                                                                          \033[32mEnvironment                         \033[0m";}
  M2(){ TPUT  8 3; $e " Автор                                                                                     \033[32mAuthor                              \033[0m";}
#
  M3(){ TPUT 12 3; $e " Запишите терминальную сессию в файл SVG                                                   \033[32mtermtosvg                           \033[0m";}
  M4(){ TPUT 13 3; $e " Запись сеанса терминала в формате asciicast v2                                            \033[32mtermtosvg record                    \033[0m";}
  M5(){ TPUT 14 3; $e " Рендеринг анимированного SVG из записи в формате asciicast v1 или v2                      \033[32mtermtosvg render                    \033[0m";}
#
  M6(){ TPUT 16 3; $e " Укажите программу для записи с необязательными аргументами                                \033[32m-c –command=COMMAND                 \033[0m";}
  M7(){ TPUT 17 3; $e " Продолжительность задержки между двумя последовательными циклами анимации в миллисекундах \033[32m-D –loop-delay=DELAY                \033[0m";}
  M8(){ TPUT 18 3; $e " Геометрия экрана терминала, используемая для рендеринга анимации                          \033[32m-g –screen-geometry=GEOMETRY        \033[0m";}
  M9(){ TPUT 19 3; $e " Распечатать использование и выход                                                         \033[32m-h –help                            \033[0m";}
 M10(){ TPUT 20 3; $e " Установите минимальную продолжительность кадра в миллисекундах                            \033[32m-m –min-frame-duration=MIN_DURATION \033[0m";}
 M11(){ TPUT 21 3; $e " Установите максимальную продолжительность кадра на MAX_DURATION миллисекунд               \033[32m-M –max-frame-duration=MAX_DURATION \033[0m";}
 M12(){ TPUT 22 3; $e " Установите шаблон SVG, используемый для рендеринга анимации SVG                           \033[32m-t –template=TEMPLATE               \033[0m";}
 M13(){ TPUT 23 3; $e " Вывод неподвижных кадров в формате SVG вместо анимированного SVG                          \033[32m-s –still-frames                    \033[0m";}
 M14(){ TPUT 24 3; $e " SVG Шаблоны                                                                               \033[32mSVG Templates                       \033[0m";}
 M15(){ TPUT 25 3; $e " Визуализация неподвижных кадров вместо анимированного SVG с использованием шаблона        \033[32m-s -t                               \033[0m";}
#
 M16(){ TPUT 27 3; $e " \033[32mExit                                                                                                                          \033[0m";}
LM=16
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
# Здесь необходимо следить за двумя перепенными 0) и S=M0 Они должны совпадать между собой и переменной списка M0().
  0) S=M0;SC;if [[ $cur == enter ]];then R;echo " termtosvg [output_path] [-c COMMAND] [-D DELAY] [-g GEOMETRY] [-m MIN_DURATION] [-M MAX_DURATION] [-s] [-t TEMPLATE] [–help]
 termtosvg record [output_path] [-c COMMAND] [-g GEOMETRY] [-h]
 termtosvg render input_file [output_path] [-D DELAY] [-m MIN_DURATION] [-M MAX_DURATION] [-s] [-t TEMPLATE] [-h]";ES;fi;;
  1) S=M1;SC;if [[ $cur == enter ]];then R;echo " Если параметр --command не указан, termtosvg создаст оболочку, указанную в переменной окружения SHELL, или /bin/sh, если переменная не задано.";ES;fi;;
  2) S=M2;SC;if [[ $cur == enter ]];then R;echo " Nicolas Bedos";ES;fi;;
  3) S=M3;SC;if [[ $cur == enter ]];then R;echo -e "
 Запишите терминальную сессию и произведите SVG анимацию по имени animation.svg:
\033[32m termtosvg animation.svg\033[0m
";ES;fi;;
  4) S=M4;SC;if [[ $cur == enter ]];then R;echo "
    Запись сеанса терминала в формате asciicast v2. Запись представляет собой текстовый файл, который содержит информацию о времени, а также то, что отображалось на
 экране во время сеанса терминала. Его можно отредактировать, чтобы изменить время записи или информацию, отображаемую на экране терминала.
 termtosvg record recording.cast
";ES;fi;;
  5) S=M5;SC;if [[ $cur == enter ]];then R;echo "
    Рендеринг анимированного SVG из записи в формате asciicast v1 или v2. Это позволяет отображать в формате SVG любую запись, сделанную с помощью asciinema.
 Рендеринг неподвижных кадров также возможно:
 termtosvg render recording.cast animation.svg
";ES;fi;;
  6) S=M6;SC;if [[ $cur == enter ]];then R;echo "
    Укажите программу для записи с необязательными аргументами. КОМАНДА должна быть строкой, перечисляющей программу для выполнения вместе со всеми аргументами
 доступны для программы. Например, --command='python -h' заставит termtosvg записывать использование интерпретатора Python. Если этот параметр не установлен,
 termtosvg запишет программу, указанную в переменной окружения \$SHELL или /bin/sh
 termtosvg -c 'ipython --pprint'
";ES;fi;;
  7) S=M7;SC;if [[ $cur == enter ]];then R;echo "
 Продолжительность задержки между двумя последовательными циклами анимации в миллисекундах:
 termtosvg -D 2000
";ES;fi;;
  8) S=M8;SC;if [[ $cur == enter ]];then R;echo -e "
    Геометрия экрана терминала, используемая для рендеринга анимации. Геометрия должна быть задана как количество столбцов и количество строк на экране разделены
 символом «х». Например, «80x24» для экрана с 82 столбцами и 19 строками:
\033[32m termtosvg -g 80x24 animation.svg\033[0m
";ES;fi;;
  9) S=M9;SC;if [[ $cur == enter ]];then R;echo " Распечатать использование и выход";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo "
    Установите минимальную продолжительность кадра в миллисекундах. Кадры продолжительностью менее MIN_DURATION миллисекунд будут объединены с последовательными
 кадрами поведение ошибки termtosvg заключается в создании кадра для каждого обновления экрана терминала, но при очень частой записи команд, которые обновляют экран,
 Это может привести к увеличению размера файла анимации. Применение минимальной продолжительности кадра помогает уменьшить количество кадров анимации и, таким
 образом, помогает контролировать размер анимации. MIN_DURATION по умолчанию составляет 1 миллисекунду:
 termtosvg -m 17 -M 2000
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo "
    Установите максимальную продолжительность кадра на MAX_DURATION миллисекунд. Кадры, длящиеся дольше MAX_DURATION миллисекунд, просто увидят, что их
 продолжительность сокращено до MAX_DURATION.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo "
    Установите шаблон SVG, используемый для рендеринга анимации SVG. ШАБЛОН может быть одним из шаблонов по умолчанию (base16_default_dark, dracula, gjm8_play,
 gjm8_single_loop, gjm8, powershell, progress_bar, шпатлевка, solarized_dark, solarized_light, terminal_app, ubuntu, window_frame_js, window_frame_powershell,
 window_frame, xterm) или путь к допустимому шаблону:
 termtosvg -t ~/templates/my_template.svg
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo "
    Вывод неподвижных кадров в формате SVG вместо анимированного SVG. Если указан этот параметр, output_path указывает на каталог назначения для кадров.
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo "
  Шаблоны позволяют настраивать анимацию SVG, создаваемую termtosvg, несколькими способами, включая, помимо прочего:
  • Указание цветовой темы и шрифта, используемых для отображения сеанса терминала.
  • Добавление пользовательской рамки окна терминала в анимацию, чтобы она выглядела как настоящий терминал.
  • Добавлен код JavaScript для приостановки анимации, перехода к определенному кадру и т. д.
  См. termtosvg-templates для более подробной информации.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo " termtosvg -s -t gjm8_play";ES;fi;;
#
 16) S=M16;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
